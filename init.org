#+property: header-args:emacs-lisp :tangle (concat (file-name-sans-extension (buffer-file-name)) ".el")
#+property: header-args :mkdirp yes :comments no
#+startup: indent

#+begin_src emacs-lisp :exports none
  ;; DO NOT EDIT THIS FILE DIRECTLY
  ;; This is a file generated from a literate programing source file located at
  ;; https://github.com/dpsutton/tangled-emacs/blob/master/init.org.
  ;; You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+end_src


#+title: My Emacs config file
#+author: Dan Sutton
#+email: dan@dpsutton.com

This is my emacs configuration file. I am basing this on the excellent version made by [[https://github.com/zzamboni/dot-emacs][zzamboni]]. I could have easily cloned his or her repo but I've never used org tangling before so I wanted to try this from scratch.

* Performance optimization.

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "Emacs ready in in %s with %d garbage collections"
                       (format "%.2f seconds"
                               (float-time
                                (time-subtract after-init-time before-init-time)))
                       gcs-done)))
#+END_SRC


Optionally enable =debug-on-error= when diagnosing errors with the config file itself.

#+begin_src emacs-lisp
  ;;(setq debug-on-error t)
#+end_src

#+begin_src emacs-lisp
  (setq personal/original-gc-threshold gc-cons-threshold)
  (setq gc-cons-threshold most-positive-fixnum)
#+end_src


* Package Management

This is the first time I've used `use-package` but its about time I ventured into it.

** Setup package locations and refresh package contents

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'package-archives
                          '(("gnu"       . "https://elpa.gnu.org/packages/")
                            ("melpa" . "https://melpa.org/packages/")))
#+END_SRC

Now we initialize the package and install =use-package= if needed.

#+BEGIN_SRC emacs-lisp
  (package-initialize)

  (when (not package-archive-contents)
    (package-refresh-contents))
#+END_SRC

** Install and configure =use-package=

#+BEGIN_SRC emacs-lisp
  (when (not (package-installed-p 'use-package))
    (package-install 'use-package))

  (require 'use-package)
#+END_SRC

- The =use-package-always-ensure= variable indicates that =use-package= should always try to install missing packages. For some libraries this is not appropriate, and in those cases you see the =:ensure nil= declaration as part of the =use-package= statement. This applies mainly to libraries which are installed as part of some other package (happens mostly with some libraries that come with org-mode).

  #+BEGIN_SRC emacs-lisp
    (customize-set-variable 'use-package-always-ensure t)
  #+END_SRC

- The =use-package-verbose= variable allows for verbosity for debugging

  #+BEGIN_SRC emacs-lisp
    (customize-set-variable 'use-package-verbose nil)
  #+END_SRC

This variable tells Emacs to prefer the =.el= file if it's newer, even if there is a corresponding =.elc= file. Also, use =auto-compile= to autocompile files as needed.

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'load-prefer-newer t)
  (use-package auto-compile
    :defer nil
    :config (auto-compile-on-load-mode))
#+END_SRC
* Settings

** General

- set dired listing settings

#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches "-alh")
#+END_SRC

- Start the Emacs server and define a shutdown function

#+begin_src emacs-lisp
    (server-start)

  (defun shutdown-server ()
    "Kill the running emacs server.
  When running emacs client, easily kill the server without ps aux,
  pkill, etc."
    (interactive)
    (save-some-buffers)
    (kill-emacs))
#+end_src

- use resize-window

#+BEGIN_SRC emacs-lisp
  (use-package resize-window
    :demand t
    :bind
    ("C-c ;" . resize-window)
    ("C-c C-;" . resize-window)
    :config
    (add-hook 'org-mode-hook
              (lambda ()
                (bind-key "C-c ;" 'resize-window org-mode-map)))
    (setq resize-window-swap-capital-and-lowercase-behavior t)
    (resize-window-add-choice ?l #'ivy-switch-buffer "Switch buffers with ivy")
    (resize-window-add-choice ?a #'counsel-git "Search git files")
    (resize-window-add-choice ?h (lambda () (dired "~/projects/clojure"))
                              "Visit the clojure directory")
    (resize-window-add-choice ?d (lambda () (dired "~/projects/dev"))
                              "Visit dev directoryq")
    (resize-window-add-choice ?m (lambda () (resize-window--window-push))
                              "Push window state onto window stack")
    (resize-window-add-choice ?v (lambda () (find-file "~/projects/projects.org"))
                              "Edit project file"))
#+END_SRC

- turn off the stupid system bell

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

- reload files when changed on disk

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC
- Set up a way to hook up multiple modes

#+BEGIN_SRC emacs-lisp
  (defun append-suffix (suffix phrases)
    "take SUFFIX and append it to each of the PHRASES."
    (mapcar #'(lambda (phrase) (concat (symbol-name phrase) suffix)) phrases))

  (defun hook-up-modes (environments hook)
    (mapc (lambda (mode) (add-hook mode hook))
          (mapcar (lambda (env) (intern (format "%s-mode-hook" env)))
                  environments)))
#+END_SRC

- When at the beginning of the line, make =Ctrl-K= remove the whole line, instead of just emptying it.

  #+begin_src emacs-lisp
    (customize-set-variable 'kill-whole-line t)
  #+end_src

- Paste text where the cursor is, not where the mouse is.

  #+begin_src emacs-lisp
    (customize-set-variable 'mouse-yank-at-point t)
  #+end_src

- Make completion case-insensitive.

  #+begin_src emacs-lisp
    (setq completion-ignore-case t)
    (customize-set-variable 'read-file-name-completion-ignore-case t)
    (customize-set-variable 'read-buffer-completion-ignore-case t)
  #+end_src

- Highlight trailing whitespace in red, so it's easily visible

  #+begin_src emacs-lisp
    (add-hook 'prog-mode-hook (lambda () (setq-local show-trailing-whitespace t)))
  #+end_src

- Highlight matching parenthesis

  #+begin_src emacs-lisp
    (show-paren-mode)
  #+end_src

- Don't use hard tabs

  #+begin_src emacs-lisp
    (customize-set-variable 'indent-tabs-mode nil)
  #+end_src

- Emacs automatically creates backup files, by default in the same folder as the original file, which often leaves backup files behind. This tells Emacs to [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html][put all backups in ~/.emacs.d/backups]].

  #+begin_src emacs-lisp
    (customize-set-variable 'backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
  #+end_src

- [[http://emacswiki.org/emacs/WinnerMode][WinnerMode]] makes it possible to cycle and undo window configuration changes (i.e. arrangement of panels, etc.)

  #+begin_src emacs-lisp
    (when (fboundp 'winner-mode) (winner-mode))
  #+end_src

- Add "unfill" commands to parallel the "fill" ones, bind ~A-q~ to =unfill-paragraph= and rebind ~M-q~ to the =unfill-toggle= command, which fills/unfills paragraphs alternatively.

  #+begin_src emacs-lisp
    (use-package unfill
      :bind
      ("M-q" . unfill-toggle)
      ("A-q" . unfill-paragraph))
  #+end_src

- Save the place of the cursor in each file, and restore it upon opening it again.

  #+begin_src emacs-lisp
    (use-package saveplace
      :defer nil
      :config
      (save-place-mode))
  #+end_src

- Provide mode-specific "bookmarks" - press =M-i= and you will be presented with a list of elements to which you can navigate - they can be headers in org-mode, function names in emacs-lisp, etc.

  #+begin_src emacs-lisp
    (use-package imenu-anywhere
      :bind ("M-i" . imenu))
  #+end_src

- Smooth scrolling (line by line) instead of jumping by half-screens.

  #+begin_src emacs-lisp
    (use-package smooth-scrolling
      :disabled
      :config
      (smooth-scrolling-mode 1))
  #+end_src

- Delete trailing whitespace before saving a file.

  #+begin_src emacs-lisp
    (add-hook 'before-save-hook 'delete-trailing-whitespace)
  #+end_src

- Suppress "ad-handle-definition: .. redefined" warnings during Emacs startup.

  #+begin_src emacs-lisp
    (customize-set-variable 'ad-redefinition-action 'accept)
  #+end_src


- Use the =bind-key= package to more easily keep track and manage user keybindings. It comes with =use-package= so we can just load it.

The main benefit is that we can ~M-x~ =describe-personal-keybindings= to see a list of all the customized keybindings defined.

#+BEGIN_SRC emacs-lisp
  (require 'bind-key)
#+END_SRC

** Backups

#+BEGIN_SRC emacs-lisp
  (setq
   make-backup-files nil
   auto-save-default nil
   create-lockfiles nil)
#+END_SRC
** Identity Machines

are we on that machine?

#+BEGIN_SRC emacs-lisp
  (defconst personal/osx-p (string= system-type "darwin"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defconst personal/linux-machine (string= system-name "pop-os"))
  (defconst personal/mac-machine (string= system-name "dan-mbp.local"))

#+END_SRC

Var to check that we are on the work machine
#+BEGIN_SRC emacs-lisp
  (defconst personal/work-machine (string= system-name "dan-aclaimant-mbp.local"))
#+END_SRC

** Appearance

You'll notice that many of the packages in this section have =:defer nil=. This is because some of these package are never called explicitly because they operate in the background, but I want them loaded when Emacs starts so they can perform their necessary customization.

Emacs 26 (which I am trying now) introduces pixel-level scrolling.

#+begin_src emacs-lisp
  (when (>= emacs-major-version 26)
    (pixel-scroll-mode))
#+end_src


The =diminish= package makes it possible to remove clutter from the modeline. Here we just load it, it gets enabled for individual packages in their corresponding declarations.

#+begin_src emacs-lisp
  (use-package diminish
    :defer 1)

  (use-package minions
    :config (minions-mode))

  (use-package moody
    :config
    (setq x-underline-at-descent-line t)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package uniquify
    :defer 1
    :ensure nil
    :custom
    (uniquify-after-kill-buffer-p t)
    (uniquify-buffer-name-style 'post-forward)
    (uniquify-strip-common-suffix t))
#+end_src

Install smart-mode-line

#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :defer 2)
#+END_SRC

Identify the location of the cursor:

#+BEGIN_SRC emacs-lisp
(use-package hl-line
    :defer nil
    :config
    (global-hl-line-mode +1))
#+END_SRC

Turn off the quite ugly ui chrome

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
#+END_SRC

*** Themes

Themes love to make the background black. So we give a temp file, never to be seen again, as the place to write down all this stuff. Clever idea from https://github.com/patrickt/emacs
#+BEGIN_SRC emacs-lisp
  (setq custom-file (make-temp-file ""))
  (setq custom-safe-themes t)
  (setq enable-local-variables :all)
#+END_SRC

#+begin_src emacs-lisp
  (defun personal/random-theme ()
    (interactive)
    (let* ((themes (custom-available-themes))
           (theme (symbol-name (nth (cl-random (length themes)) themes))))
      (message "Loading: %s" theme)
      (counsel-load-theme-action theme)))

  (bind-key "C-c l" #'personal/random-theme)
#+end_src

#+begin_src emacs-lisp
  (use-package solarized-theme)
  (use-package kaolin-themes)
  (use-package sublime-themes)

  (use-package gruvbox-theme)
  (load-theme 'kaolin-light)
  (set-face-foreground 'highlight "black")
  (set-face-background 'highlight "LightBlue")
#+end_src



** General Packages

=projectile-mode= allows us to perform project-relative operations such as searches, navigation, etc.

#+begin_src emacs-lisp
  (use-package projectile
    :defer 2
    :diminish projectile-mode
    :config
    (projectile-global-mode))
#+end_src

- The [[https://github.com/justbur/emacs-which-key][which-key]] package makes Emacs functionality much easier to discover and explore: in short, after you start the input of a command and stop, pondering what key must follow, it will automatically open a non-intrusive buffer at the bottom of the screen offering you suggestions for completing the command, that's it, nothing else. It's beautiful.

  #+begin_src emacs-lisp
    (use-package which-key
      :defer nil
      :diminish which-key-mode
      :config
      (which-key-mode))
  #+end_src

- Hydra allows for easily configured menus

#+BEGIN_SRC emacs-lisp
  (use-package hydra)
#+END_SRC

- crux

very convenient package from bbatsov

#+BEGIN_SRC emacs-lisp
    (use-package crux
      :bind
      ([remap kill-whole-line] . crux-kill-whole-line)
      ("C-c n" . crux-cleanup-buffer-or-region)
      ("C-M-z" . crux-indent-defun)
      ("C-c t" . crux-visit-term-buffer)
      ("C-a" . crux-move-beginning-of-line)
      :config
      (require 'crux)
      (crux-with-region-or-line kill-region))
#+END_SRC

*** Completion

=company-mode= for completion

#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish company-mode
    :bind ("TAB" . company-indent-or-complete-common)
    :hook
    (after-init . global-company-mode)
    :config
    (setq company-idle-delay 0.3)
    (setq company-minimum-prefix-length 3))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :init (company-quickhelp-mode)
    :config
    (setq company-quickhelp-use-propertized-text t)
    (setq company-quickhelp-delay 0.2))
#+END_SRC

** Neotree/sidebar

#+begin_src emacs-lisp
  (use-package all-the-icons)
  (use-package neotree
    :config
    (customize-set-variable 'neo-theme (if (display-graphic-p) 'icons 'arrow))
    (customize-set-variable 'neo-smart-open t)
    ;;(customize-set-variable 'projectile-switch-project-action 'neotree-projectile-action)
    (defun neotree-project-dir ()
      "Open NeoTree using the git root."
      (interactive)
      (let ((project-dir (projectile-project-root))
            (file-name (buffer-file-name)))
        (neotree-toggle)
        (if project-dir
            (if (neo-global--window-exists-p)
                (progn
                  (neotree-dir project-dir)
                  (neotree-find file-name)))
          (message "Could not find git project root."))))
    :bind
    ([f8] . neotree-project-dir))
#+end_src


** Visuals

Thanks https://github.com/patrickt/emacs

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)

  (use-package all-the-icons-dired
    :after all-the-icons
    :hook (dired-mode . all-the-icons-dired-mode))
#+END_SRC
* Text Editing Settings

** Text environment hook
Define standard text environments

#+BEGIN_SRC emacs-lisp
  (defvar my-text-environments '(org markdown))
#+END_SRC

Turn off whitespace mode and make word wrapping work as in a normal text editor.

#+BEGIN_SRC emacs-lisp
  (defun standard-text-environment ()
    (visual-line-mode)
    (whitespace-mode -1))

  (hook-up-modes my-text-environments 'standard-text-environment)
#+END_SRC

** General

Tab settings. No tabs inserted but tabs have a width of 8.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq tab-width 8)
#+END_SRC

** Scrolling

Scolling will recenter which leaves the repl prompt in the middle of the buffer just wasting tons of space. Prefer to have it just stay right above the bottom. Can do this with =scroll-conservatively= with a value greater than 100.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 101)
#+END_SRC
** Copy/Paste related

#+BEGIN_SRC emacs-lisp
  (use-package browse-kill-ring
    :demand t
    :config
    (browse-kill-ring-default-keybindings)
    :bind
    ("s-y" . browse-kill-ring))
#+END_SRC

Allow for pasting over things

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC
** Undo

Use undo tree

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :init
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t))

#+END_SRC

** Text size

#+BEGIN_SRC emacs-lisp
  (bind-key "C-+" 'text-scale-increase)
  (bind-key "C--" 'text-scale-decrease)
#+END_SRC

* Pdf

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :demand t
    :config
    (require 'pdf-tools)
    (require 'pdf-view)
    :bind (:map pdf-view-mode-map
                ("j" . pdf-view-next-line-or-next-page)
                ("k" . pdf-view-previous-line-or-previous-page)
                ("h" . image-backward-hscroll)
                ("l" . image-forward-hscroll)))
#+END_SRC
* Org

** Initial setup

Org is lovely except i prefer my =resize-window= command at =C-c ;= instead of the toggle comment command.

Require org-tempo so that when typing ~<s~ it will expand out into the source block template. A recent change in org moved this and it now needs to be required

#+BEGIN_SRC emacs-lisp
  (use-package org
    :bind
    ([remap org-toggle-comment] . resize-window)
    :init
    (condition-case nil
        (require 'org-tempo)
      ((error) nil)))
#+END_SRC

** Presentations

Using instructions for org-reveal from https://github.com/yjwen/org-reveal/

#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :config
    (setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"))
#+END_SRC

htmlize so that code blocks use emacs theme
#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC
* Searching

** Ibuffer

This seems quite powerful but I never think to use it. Need to read the help menu under =h= when in =ibuffer-mode=
#+begin_src emacs-lisp
  (use-package ibuffer
    :bind
    ("C-x C-b" . ibuffer))
#+end_src

** Interactive search

- Interactive search key bindings -  [[https://github.com/benma/visual-regexp-steroids.el][visual-regexp-steroids]] provides sane regular expressions and visual incremental search. We make ~C-s~ and ~C-r~ run the visual-regexp functions. We leave ~C-M-s~ and ~C-M-r~ to run the default =isearch-forward/backward= functions, as a fallback. I use the =pcre2el= package to support PCRE-style regular expressions.

  #+begin_src emacs-lisp
    (use-package pcre2el)
    (use-package visual-regexp-steroids
      :custom
      (vr/engine 'pcre2el "Use PCRE regular expressions")
      :bind
      ("C-c r" . vr/replace)
      ("C-c q" . vr/query-replace)
      ("C-r"   . vr/isearch-backward)
      ("C-S-s" . vr/isearch-forward)
      ("C-M-s" . isearch-forward)
      ("C-M-r" . isearch-backward))
  #+end_src

** Loccur

#+BEGIN_SRC emacs-lisp
  (use-package loccur
    :bind ("C-o" . loccur-current))
#+END_SRC

** Ivy

Enable. In my last config i saw that i included =(setq enable-recursive-minibuffers t)= but I don't remember why I did this. Perhaps will be necessary? Sure is nice to have literate docs.

Define my own "thing at point" ag function

#+BEGIN_SRC emacs-lisp
  (defun personal/ag-at-point ()
    (interactive)
    (let ((current-word (thing-at-point 'symbol)))
      (counsel-ag current-word)))

#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :demand t
    :bind
    ("C-c C-r" . ivy-resume)
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich
    :custom
    (ivy-virtual-abbreviate 'full)
    (ivy-rich-switch-buffer-align-virtual-buffer nil)
    (ivy-rich-path-style 'full)
    :config
    (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
    (ivy-rich-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :bind
    ("M-x" . counsel-M-x)
    ("C-r" . personal/ag-at-point)
    ("C-x C-f" . counsel-find-file)
    ("C-x l" . counsel-locate)
    ("C-S-o" . counsel-rhythmbox)
    ("C-s" . swiper))
#+END_SRC
* Coding

** All

*** Standard packages

- paredit

#+BEGIN_SRC emacs-lisp
    (use-package paredit)
#+END_SRC

- rainbow delimiters mode

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters)
#+END_SRC

- magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status))
#+END_SRC

*** Keybindings

*** eldoc

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :diminish
    :hook
    (prog-mode . turn-on-eldoc-mode))
#+END_SRC

*** flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck)
#+END_SRC

** Lisps

Standard lisp editing environment
#+BEGIN_SRC emacs-lisp
  (defun standard-lisp-environment ()
    (paredit-mode 1)
    (rainbow-delimiters-mode 1)
    (eldoc-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defconst personal/my-lisps '(clojure lisp emacs-lisp cider-repl geiser
                                        geiser-repl scheme inf-clojure
                                        ;;racket slime repl
                                        ))

  (hook-up-modes personal/my-lisps #'standard-lisp-environment)

#+END_SRC
** Shells

vterm looks promising: https://github.com/akermu/emacs-libvterm
be aware of this: https://github.com/akermu/emacs-libvterm#shell-side-configuration

needed two things:
1. brew reinstall emacs-mac --with-modules
2. brew install cmake
3. need the following in the fish shell
#+BEGIN_SRC fish
  function vterm_printf;
      if [ -n "$TMUX" ]
          # tell tmux to pass the escape sequences through
          # (Source: http://permalink.gmane.org/gmane.comp.terminal-emulators.tmux.user/1324)
          printf "\ePtmux;\e\e]%s\007\e\\" "$argv"
      else if string match -q -- "screen*" "$TERM"
          # GNU screen (screen, screen-256color, screen-256color-bce)
          printf "\eP\e]%s\007\e\\" "$argv"
      else
          printf "\e]%s\e\\" "$argv"
      end
  end

  funcsave vterm_printf
#+END_SRC

This is the bees knees. vterm makes the buffer and can use ~-C-c C-t~ to go into edit mode.

#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :config
    (defun turn-off-chrome ()
      (hl-line-mode -1)
      (display-line-numbers-mode -1))
    :ensure t
    :hook (vterm-mode . turn-off-chrome))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x m" 'eshell)
  (bind-key "C-x M" (lambda () (interactive) (eshell t)))
#+END_SRC

*** fish
#+BEGIN_SRC emacs-lisp
  (use-package fish-mode)

#+END_SRC

** Yasnippet

Need yasnippet for lsp-mode. And why not. It's a good thing

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :demand t
    :config
    (yas-global-mode 1)
    (setq yas-snippet-dirs (list "~/.emacs.d/snippets")))
#+END_SRC
** Clojure

*** CIDER

Get the dependencies for cider

#+BEGIN_SRC emacs-lisp
  (use-package parseedn)
  (use-package pkg-info)
  (use-package queue)
  (use-package spinner)
  (use-package seq)
  (use-package sesman)
  (use-package buttercup)
#+END_SRC

For some reason paredit is acting strange
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :bind (:map
           paredit-mode-map
           ("C-j" . nil)
           ("{" . paredit-open-curly)))
#+END_SRC

Clojure mode and CIDER are dev versions locally

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-clj-kondo
    :init
    (add-hook 'after-init-hook #'global-flycheck-mode))

  (use-package clojure-mode
    :load-path "~/projects/dev/clojure-mode"
    :config
    (setq clojure-toplevel-inside-comment-form t)
    (setq clojure-indent-style 'align-arguments)
    (put-clojure-indent 'dofor 1)
    (put-clojure-indent 'match 1)

    (put-clojure-indent 'context 1)
    (put-clojure-indent 'GET 1)
    (put-clojure-indent 'compojure/GET 1)
    (put-clojure-indent 'compojure/POST 1)
    (put-clojure-indent 'compojure/PATCH 1)
    (put-clojure-indent 'compojure/PUT 1)
    (put-clojure-indent 'compojure/DELETE 1)
    (put-clojure-indent 'POST 1)
    (put-clojure-indent 'PATCH 1)
    (put-clojure-indent 'DELETE 1))

  ;; testing dependency for inf-clojure
  (use-package assess)

  (use-package inf-clojure
    :demand t
    :load-path "~/projects/dev/inf-clojure/"
    :bind (:map
           inf-clojure-mode-map
           ("RET" . newline)
           ("C-j" . comint-send-input)))

  (use-package cider
    :load-path "~/projects/dev/cider/"
    :init
    (load "cider-autoloads" t t)
    :config
    (setq cider-invert-insert-eval-p t)
    (setq cider-switch-to-repl-on-insert nil)
    (setq cider-font-lock-dynamically t)
    (setq cider-show-error-buffer nil)
    (setq cider-repl-display-help-banner nil)
    (setq cider-repl-pop-to-buffer-on-connect 'display-only)
    (setq cider-repl-tab-command #'company-indent-or-complete-common)
    :bind (:map
           cider-repl-mode-map
           ("RET" . cider-repl-newline-and-indent)
           ("C-j" . cider-repl-return)
           ;; :map
           ;; paredit-mode-map
           ;; ("C-j" . cider-repl-return)
           ))

#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun personal/unhook-cider ()
    (seq-doseq (buffer (buffer-list))
      (with-current-buffer buffer
        (cider-mode -1))
      (remove-hook 'clojure-mode-hook #'cider-mode)))

#+END_SRC
****  tooltip for doc stuff
#+BEGIN_SRC emacs-lisp
  (use-package pos-tip)

  (defun cider-tooltip-show ()
    (interactive)
    (if-let ((info (cider-var-info (thing-at-point 'symbol))))
        (nrepl-dbind-response info (doc arglists-str name ns)
          (pos-tip-show (format "%s : %s\n%s\n%s" ns (or name "") (or arglists-str "") (or doc ""))
                        nil
                        nil
                        nil
                        -1))
      (message "info not found")))

  (bind-key "C-c t" 'cider-tooltip-show)
#+END_SRC
*** LSP

Use lsp-mode with the excellent lsp-clojure package.

#+BEGIN_SRC emacs-lisp
  (when (or personal/work-machine personal/mac-machine)
    (use-package lsp-mode
      :init
      (setq lsp-clojure-server-command '("bash" "-c" "cd ~/projects/clojure/clojure-lsp && lein run"))
      (setq lsp-enable-indentation nil)
      ;; (setq lsp-enable-completion-at-point nil)
      ;; (setq indent-region-function #'clojure-indent-function)
      (add-hook 'clojure-mode-hook #'lsp)
      (add-hook 'clojurec-mode-hook #'lsp)
      (add-hook 'clojurescript-mode-hook #'lsp)
      :config
      (require 'lsp-clojure)
      (add-to-list 'lsp-language-id-configuration '(clojure-mode . "clojure"))
      (add-to-list 'lsp-language-id-configuration '(clojurec-mode . "clojure"))
      (add-to-list 'lsp-language-id-configuration '(clojurescript-mode . "clojurescript"))))
#+END_SRC

Use the hydra I cooked up recently

#+BEGIN_SRC emacs-lisp
  (when (or personal/work-machine personal/mac-machine)
    (use-package lsp-clojure-hydra
      :after (lsp-mode lsp-mode cider)
      :load-path "~/projects/elisp/lsp-clojure-hydra"
      :bind (("C-c C-l" . lsp-clojure-refactor-menu/body)
             :map
             cider-mode-map
             ("C-c C-l" . lsp-clojure-refactor-menu/body))))
#+END_SRC
** Rust

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode)
  (use-package racer
    :init
    (add-hook 'rust-mode-hook #'racer-mode)
    (add-hook 'racer-mode-hook #'eldoc-mode)
    (add-hook 'racer-mode-hook #'company-mode)
    (setq company-tooltip-align-annotations t)
    :bind (:map
           rust-mode-map
           ("TAB" . company-indent-or-complete-common)))
#+END_SRC
** Haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode)
#+END_SRC

Intero is no longer supported. Trying with just haskell lsp. Taken from https://github.com/jwiegley/dot-emacs/blob/master/init.el

#+begin_src emacs-lisp
  (use-package lsp-haskell
    :disabled t
    :after lsp-mode
    :hook (haskell-mode . lsp-haskell-enable))
#+end_src
** Prolog

Information taken from https://www.metalevel.at/pceprolog/ so I can
follow along with https://www.metalevel.at/prolog/facets.

Require prolog-mode. a built-in to emacs

#+BEGIN_SRC emacs-lisp
  (defun prolog-insert-prompt ()
    (interactive)
    (insert "\n%?- "))

  (defun prolog-insert-comment-block ()
    "Insert a PceEmacs-style comment block like /* - - ... - - */ "
    (interactive)
    (let ((dashes "-"))
      (dotimes (_ 36) (setq dashes (concat "- " dashes)))
      (insert (format "/* %s\n\n%s */" dashes dashes))
      (forward-line -1)
      (indent-for-tab-command)))

  (use-package prolog
    :after (ediprolog)
    :config
    (setq prolog-system 'swi
          prolog-program-switches '((swi ("-G128M" "-T128M" "-L128M" "-O"))
                                    (t nil))
          prolog-electric-if-then-else-flag t)
    :bind (:map prolog-mode-map
                ("C-c C-k" . ediprolog-dwim)
                ("C-c k" . ediprolog-dwim)
                ("C-;" . prolog-insert-comment-block)
                ("C-c j" . prolog-insert-prompt)
                ("C-c C-j" . prolog-insert-prompt)))
#+END_SRC


Then use ediprolog mode. Doesn't seem super necessary as prolog-mode allows me to consult a buffer and get a prolog up and running but here we are.

#+BEGIN_SRC emacs-lisp
  (use-package ediprolog)
#+END_SRC
** Scheme

#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :bind (:map geiser-repl-mode-map
                ("C-j" . geiser-repl--maybe-send)
                ("RET" . indent-new-comment-line)
                ("C-a" . crux-move-beginning-of-line)
                ([return] . indent-new-comment-line)))
#+END_SRC
* Machine Configs
** Work

*** Connect to running services

#+BEGIN_SRC emacs-lisp
  (when personal/work-machine
    (defmacro aclaimant-cider-connection (name&dir port)
      `(defun ,(intern (format "aclaimant-jack-in-%s" (symbol-name name&dir))) ()
         ,(format "Jack into project %s and open its base directory." name&dir)
         (interactive)
         (let ((dir ,(format "~/projects/aclaimant/acl/src/aclaimant/"
                             (symbol-name name&dir))))
           (cider-connect (list :host "local.aclaimant.com" :port ,port
                                :project-dir dir)))))

    (aclaimant-cider-connection service 7000)
    (aclaimant-cider-connection jobs 7001)
    (aclaimant-cider-connection alerter 7002)
    (aclaimant-cider-connection twilio 7004)

    (defun aclaimant-jack-in-dashboard ()
      (interactive)
      (cider-connect-cljs (list :host "localhost"
                                :port 7888
                                :cljs-repl-type 'figwheel-connected
                                'project-dir "~/projects/aclaimant/acl")))

    (resize-window-add-choice ?u (lambda () (dired "~/projects/aclaimant/acl"))
                              "Work projects"))

#+END_SRC
*** DONE Ligatures

#+BEGIN_SRC emacs-lisp
  (when personal/osx-p
    (mac-auto-operator-composition-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :demand t
    :init
    (exec-path-from-shell-initialize))
#+END_SRC

*** Random assorteds

#+BEGIN_SRC emacs-lisp
  (when personal/osx-p
    (setq mac-command-modifier 'meta))

  (when personal/work-machine
    (global-display-line-numbers-mode +1))
#+END_SRC

** Any

*** Set font

For some reason this was getting lost in the startup shenanigans so we set it once things settle down.

#+BEGIN_SRC emacs-lisp
  (set-frame-font "Fira Code" nil t)
  (defun personal/set-font ()
    (interactive)
    (set-face-attribute 'default nil :height (cond
                                              (personal/linux-machine 130)
                                              (personal/mac-machine 150)
                                              (t 140))))
  (add-hook 'emacs-startup-hook #'personal/set-font)
#+END_SRC
* Post

** Restore gc

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold personal/original-gc-threshold)
#+END_SRC
