#+property: header-args:emacs-lisp :tangle (concat (file-name-sans-extension (buffer-file-name)) ".el")
#+property: header-args :mkdirp yes :comments no
#+startup: indent

#+begin_src emacs-lisp :exports none
  ;; DO NOT EDIT THIS FILE DIRECTLY
  ;; This is a file generated from a literate programing source file located at
  ;; https://github.com/dpsutton/tangled-emacs/blob/master/init.org.
  ;; You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+end_src


#+title: My Emacs config file
#+author: Dan Sutton
#+email: dan@dpsutton.com

This is my emacs configuration file. I am basing this on the excellent version made by [[https://github.com/zzamboni/dot-emacs][zzamboni]]. I could have easily cloned his or her repo but I've never used org tangling before so I wanted to try this from scratch.

* Performance optimization.

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "Emacs ready in in %s with %d garbage collections"
                       (format "%.2f seconds"
                               (float-time
                                (time-subtract after-init-time before-init-time)))
                       gcs-done)))
#+END_SRC


Optionally enable =debug-on-error= when diagnosing errors with the config file itself.

#+begin_src emacs-lisp
  ;;(setq debug-on-error t)
#+end_src

#+begin_src emacs-lisp
  (setq personal/original-gc-threshold gc-cons-threshold)
  (setq gc-cons-threshold most-positive-fixnum)
#+end_src

* Customized variables
#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (when (file-exists-p custom-file)
   (load custom-file))
#+END_SRC

* Package Management

This is the first time I've used `use-package` but its about time I ventured into it.

** Setup package locations and refresh package contents

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'package-archives
                          '(("gnu"       . "https://elpa.gnu.org/packages/")
                            ("melpa" . "https://melpa.org/packages/")))
#+END_SRC

Now we initialize the package and install =use-package= if needed.

#+BEGIN_SRC emacs-lisp
  (package-initialize)

  (when (not package-archive-contents)
    (package-refresh-contents))
#+END_SRC

** Install and configure =use-package=

#+BEGIN_SRC emacs-lisp
  (when (not (package-installed-p 'use-package))
    (package-install 'use-package))

  (require 'use-package)
#+END_SRC

- The =use-package-always-ensure= variable indicates that =use-package= should always try to install missing packages. For some libraries this is not appropriate, and in those cases you see the =:ensure nil= declaration as part of the =use-package= statement. This applies mainly to libraries which are installed as part of some other package (happens mostly with some libraries that come with org-mode).

  #+BEGIN_SRC emacs-lisp
    (customize-set-variable 'use-package-always-ensure t)
  #+END_SRC

- The =use-package-verbose= variable allows for verbosity for debugging

  #+BEGIN_SRC emacs-lisp
    (customize-set-variable 'use-package-verbose nil)
  #+END_SRC

This variable tells Emacs to prefer the =.el= file if it's newer, even if there is a corresponding =.elc= file. Also, use =auto-compile= to autocompile files as needed.

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'load-prefer-newer t)
  (use-package auto-compile
    :defer nil
    :config (auto-compile-on-load-mode))
#+END_SRC
* Settings

** General

- set dired listing settings

#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches "-alh")
#+END_SRC

- Start the Emacs server and define a shutdown function

#+begin_src emacs-lisp
    (server-start)

  (defun shutdown-server ()
    "Kill the running emacs server.
  When running emacs client, easily kill the server without ps aux,
  pkill, etc."
    (interactive)
    (save-some-buffers)
    (kill-emacs))
#+end_src

- use resize-window

#+BEGIN_SRC emacs-lisp
  (use-package resize-window
    :demand t
    :bind
    ("C-c ;" . resize-window)
    ("C-c C-;" . resize-window)
    :config
    (add-hook 'org-mode-hook
              (lambda ()
                (bind-key "C-c ;" 'resize-window org-mode-map)))
    (setq resize-window-swap-capital-and-lowercase-behavior t)
    (resize-window-add-choice ?l #'ivy-switch-buffer "Switch buffers with ivy")
    (resize-window-add-choice ?a #'counsel-git "Search git files")
    (resize-window-add-choice ?h (lambda () (dired "~/projects/clojure"))
                              "Visit the clojure directory")
    (resize-window-add-choice ?d (lambda () (dired "~/projects/dev"))
                              "Visit dev directoryq")
    (resize-window-add-choice ?m (lambda () (resize-window--window-push))
                              "Push window state onto window stack"))
#+END_SRC

- turn off the stupid system bell

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

- reload files when changed on disk

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC
- Set up a way to hook up multiple modes

#+BEGIN_SRC emacs-lisp
  (defun append-suffix (suffix phrases)
    "take SUFFIX and append it to each of the PHRASES."
    (mapcar #'(lambda (phrase) (concat (symbol-name phrase) suffix)) phrases))

  (defun hook-up-modes (environments hook)
    (mapc (lambda (mode) (add-hook mode hook))
          (mapcar (lambda (env) (intern (format "%s-mode-hook" env)))
                  environments)))
#+END_SRC

- When at the beginning of the line, make =Ctrl-K= remove the whole line, instead of just emptying it.

  #+begin_src emacs-lisp
    (customize-set-variable 'kill-whole-line t)
  #+end_src

- Paste text where the cursor is, not where the mouse is.

  #+begin_src emacs-lisp
    (customize-set-variable 'mouse-yank-at-point t)
  #+end_src

- Make completion case-insensitive.

  #+begin_src emacs-lisp
    (setq completion-ignore-case t)
    (customize-set-variable 'read-file-name-completion-ignore-case t)
    (customize-set-variable 'read-buffer-completion-ignore-case t)
  #+end_src

- Highlight trailing whitespace in red, so it's easily visible

  #+begin_src emacs-lisp
    (customize-set-variable 'show-trailing-whitespace t)
  #+end_src

- Highlight matching parenthesis

  #+begin_src emacs-lisp
    (show-paren-mode)
  #+end_src

- Don't use hard tabs

  #+begin_src emacs-lisp
    (customize-set-variable 'indent-tabs-mode nil)
  #+end_src

- Emacs automatically creates backup files, by default in the same folder as the original file, which often leaves backup files behind. This tells Emacs to [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html][put all backups in ~/.emacs.d/backups]].

  #+begin_src emacs-lisp
    (customize-set-variable 'backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
  #+end_src

- [[http://emacswiki.org/emacs/WinnerMode][WinnerMode]] makes it possible to cycle and undo window configuration changes (i.e. arrangement of panels, etc.)

  #+begin_src emacs-lisp
    (when (fboundp 'winner-mode) (winner-mode))
  #+end_src

- Add "unfill" commands to parallel the "fill" ones, bind ~A-q~ to =unfill-paragraph= and rebind ~M-q~ to the =unfill-toggle= command, which fills/unfills paragraphs alternatively.

  #+begin_src emacs-lisp
    (use-package unfill
      :bind
      ("M-q" . unfill-toggle)
      ("A-q" . unfill-paragraph))
  #+end_src

- Save the place of the cursor in each file, and restore it upon opening it again.

  #+begin_src emacs-lisp
    (use-package saveplace
      :defer nil
      :config
      (save-place-mode))
  #+end_src

- Provide mode-specific "bookmarks" - press =M-i= and you will be presented with a list of elements to which you can navigate - they can be headers in org-mode, function names in emacs-lisp, etc.

  #+begin_src emacs-lisp
    (use-package imenu-anywhere
      :bind ("M-i" . imenu))
  #+end_src

- Smooth scrolling (line by line) instead of jumping by half-screens.

  #+begin_src emacs-lisp
    (use-package smooth-scrolling
      :disabled
      :config
      (smooth-scrolling-mode 1))
  #+end_src

- Delete trailing whitespace before saving a file.

  #+begin_src emacs-lisp
    (add-hook 'before-save-hook 'delete-trailing-whitespace)
  #+end_src

- Suppress "ad-handle-definition: .. redefined" warnings during Emacs startup.

  #+begin_src emacs-lisp
    (customize-set-variable 'ad-redefinition-action 'accept)
  #+end_src


- Use the =bind-key= package to more easily keep track and manage user keybindings. It comes with =use-package= so we can just load it.

The main benefit is that we can ~M-x~ =describe-personal-keybindings= to see a list of all the customized keybindings defined.

#+BEGIN_SRC emacs-lisp
  (require 'bind-key)
#+END_SRC


** Appearance

You'll notice that many of the packages in this section have =:defer nil=. This is because some of these package are never called explicitly because they operate in the background, but I want them loaded when Emacs starts so they can perform their necessary customization.

Emacs 26 (which I am trying now) introduces pixel-level scrolling.

#+begin_src emacs-lisp
  (when (>= emacs-major-version 26)
    (pixel-scroll-mode))
#+end_src


The =diminish= package makes it possible to remove clutter from the modeline. Here we just load it, it gets enabled for individual packages in their corresponding declarations.

#+begin_src emacs-lisp
  (use-package diminish
    :defer 1)

  (use-package minions
    :config (minions-mode))

  (use-package moody
    :config
    (setq x-underline-at-descent-line t)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package uniquify
    :defer 1
    :ensure nil
    :custom
    (uniquify-after-kill-buffer-p t)
    (uniquify-buffer-name-style 'post-forward)
    (uniquify-strip-common-suffix t))
#+end_src

Install smart-mode-line

#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :defer 2)
#+END_SRC

Identify the location of the cursor:

#+BEGIN_SRC emacs-lisp
(use-package hl-line
    :defer nil
    :config
    (global-hl-line-mode +1))
#+END_SRC

Turn off the quite ugly ui chrome

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
#+END_SRC

*** Themes

#+begin_src emacs-lisp
  (use-package solarized-theme)
  (use-package darktooth-theme)
  (use-package kaolin-themes)
  (use-package sublime-themes)

  (use-package gruvbox-theme)
  (load-theme 'brin)
  (setq hl-line-face '((t :background "#3d424d")))
#+end_src



** General Packages

=projectile-mode= allows us to perform project-relative operations such as searches, navigation, etc.

#+begin_src emacs-lisp
  (use-package projectile
    :defer 2
    :diminish projectile-mode
    :config
    (projectile-global-mode))
#+end_src

- The [[https://github.com/justbur/emacs-which-key][which-key]] package makes Emacs functionality much easier to discover and explore: in short, after you start the input of a command and stop, pondering what key must follow, it will automatically open a non-intrusive buffer at the bottom of the screen offering you suggestions for completing the command, that's it, nothing else. It's beautiful.

  #+begin_src emacs-lisp
    (use-package which-key
      :defer nil
      :diminish which-key-mode
      :config
      (which-key-mode))
  #+end_src

- Hydra allows for easily configured menus

#+BEGIN_SRC emacs-lisp
  (use-package hydra)
#+END_SRC

- crux

very convenient package from bbatsov

#+BEGIN_SRC emacs-lisp
    (use-package crux
      :bind
      ([remap kill-whole-line] . crux-kill-whole-line)
      ("C-c n" . crux-cleanup-buffer-or-region)
      ("C-M-z" . crux-indent-defun)
      ("C-c t" . crux-visit-term-buffer)
      ("C-a" . crux-move-beginning-of-line)
      :config
      (require 'crux)
      (crux-with-region-or-line kill-region))
#+END_SRC

*** Completion

=company-mode= for completion

#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish company-mode
    :bind ("TAB" . company-indent-or-complete-common)
    :hook
    (after-init . global-company-mode)
    :config
    (setq company-idle-delay 0.3)
    (setq company-minimum-prefix-length 3))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :init (company-quickhelp-mode)
    :config
    (setq company-quickhelp-use-propertized-text t)
    (setq company-quickhelp-delay 0.2))
#+END_SRC

** Neotree/sidebar

#+begin_src emacs-lisp
  (use-package all-the-icons)
  (use-package neotree
    :config
    (customize-set-variable 'neo-theme (if (display-graphic-p) 'icons 'arrow))
    (customize-set-variable 'neo-smart-open t)
    ;;(customize-set-variable 'projectile-switch-project-action 'neotree-projectile-action)
    (defun neotree-project-dir ()
      "Open NeoTree using the git root."
      (interactive)
      (let ((project-dir (projectile-project-root))
            (file-name (buffer-file-name)))
        (neotree-toggle)
        (if project-dir
            (if (neo-global--window-exists-p)
                (progn
                  (neotree-dir project-dir)
                  (neotree-find file-name)))
          (message "Could not find git project root."))))
    :bind
    ([f8] . neotree-project-dir))
#+end_src


* Text Editing Settings

** Text environment hook
Define standard text environments

#+BEGIN_SRC emacs-lisp
  (defvar my-text-environments '(org markdown))
#+END_SRC

Turn off whitespace mode and make word wrapping work as in a normal text editor.

#+BEGIN_SRC emacs-lisp
  (defun standard-text-environment ()
    (visual-line-mode)
    (whitespace-mode -1))

  (hook-up-modes my-text-environments 'standard-text-environment)
#+END_SRC

** General

Tab settings. No tabs inserted but tabs have a width of 8.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq tab-width 8)
#+END_SRC

** Scrolling

Scolling will recenter which leaves the repl prompt in the middle of the buffer just wasting tons of space. Prefer to have it just stay right above the bottom. Can do this with =scroll-conservatively= with a value greater than 100.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 101)
#+END_SRC
** Copy/Paste related

#+BEGIN_SRC emacs-lisp
  (use-package browse-kill-ring
    :demand t
    :config
    (browse-kill-ring-default-keybindings)
    :bind
    ("s-y" . browse-kill-ring))
#+END_SRC

Allow for pasting over things

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC
** Undo

Use undo tree

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :init
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t))

#+END_SRC

** Text size

#+BEGIN_SRC emacs-lisp
  (bind-key "C-+" 'text-scale-increase)
  (bind-key "C--" 'text-scale-decrease)
#+END_SRC

* Pdf

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :demand t
    :config
    (require 'pdf-tools)
    (require 'pdf-view)
    :bind (:map pdf-view-mode-map
                ("j" . pdf-view-next-line-or-next-page)
                ("k" . pdf-view-previous-line-or-previous-page)
                ("h" . image-backward-hscroll)
                ("l" . image-forward-hscroll)))
#+END_SRC
* Org

** Initial setup

Org is lovely except i prefer my =resize-window= command at =C-c ;= instead of the toggle comment command.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :bind
    ([remap org-toggle-comment] . resize-window))
#+END_SRC

** Presentations

Using instructions for org-reveal from https://github.com/yjwen/org-reveal/

#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :config
    (setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"))
#+END_SRC

htmlize so that code blocks use emacs theme
#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC
* Searching

** Ibuffer

This seems quite powerful but I never think to use it. Need to read the help menu under =h= when in =ibuffer-mode=
#+begin_src emacs-lisp
  (use-package ibuffer
    :bind
    ("C-x C-b" . ibuffer))
#+end_src

** Interactive search

- Interactive search key bindings -  [[https://github.com/benma/visual-regexp-steroids.el][visual-regexp-steroids]] provides sane regular expressions and visual incremental search. We make ~C-s~ and ~C-r~ run the visual-regexp functions. We leave ~C-M-s~ and ~C-M-r~ to run the default =isearch-forward/backward= functions, as a fallback. I use the =pcre2el= package to support PCRE-style regular expressions.

  #+begin_src emacs-lisp
    (use-package pcre2el)
    (use-package visual-regexp-steroids
      :custom
      (vr/engine 'pcre2el "Use PCRE regular expressions")
      :bind
      ("C-c r" . vr/replace)
      ("C-c q" . vr/query-replace)
      ("C-r"   . vr/isearch-backward)
      ("C-S-s" . vr/isearch-forward)
      ("C-M-s" . isearch-forward)
      ("C-M-r" . isearch-backward))
  #+end_src

** Loccur

#+BEGIN_SRC emacs-lisp
  (use-package loccur
    :bind ("C-o" . loccur-current))
#+END_SRC

** Ivy

Enable. In my last config i saw that i included =(setq enable-recursive-minibuffers t)= but I don't remember why I did this. Perhaps will be necessary? Sure is nice to have literate docs.

Define my own "thing at point" ag function

#+BEGIN_SRC emacs-lisp
  (defun personal/ag-at-point ()
    (interactive)
    (let ((current-word (thing-at-point 'symbol)))
      (counsel-ag current-word)))

#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :demand t
    :bind
    ("C-c C-r" . ivy-resume)
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :bind
    ("M-x" . counsel-M-x)
    ("C-r" . personal/ag-at-point)
    ("C-x C-f" . counsel-find-file)
    ("C-x l" . counsel-locate)
    ("C-S-o" . counsel-rhythmbox)
    ("C-s" . swiper))
#+END_SRC
* Coding

** All

*** Standard packages

- paredit

#+BEGIN_SRC emacs-lisp
    (use-package paredit)
#+END_SRC

- rainbow delimiters mode

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters)
#+END_SRC

- magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status))
#+END_SRC

*** Keybindings

*** eldoc

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :diminish
    :hook
    (prog-mode . turn-on-eldoc-mode))
#+END_SRC

*** flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck)
#+END_SRC

** Lisps

Standard lisp editing environment
#+BEGIN_SRC emacs-lisp
  (defun standard-lisp-environment ()
    (paredit-mode 1)
    (rainbow-delimiters-mode 1)
    (eldoc-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defconst personal/my-lisps '(clojure lisp emacs-lisp cider-repl
                                        ;; geiser geiser-repl racket scheme slime repl
                                        ))

  (hook-up-modes personal/my-lisps #'standard-lisp-environment)

#+END_SRC
** Shells

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x m" 'eshell)
  (bind-key "C-x M" (lambda () (interactive) (eshell t)))
#+END_SRC

*** fish
#+BEGIN_SRC emacs-lisp
  (use-package fish-mode)

#+END_SRC

** Yasnippet

Need yasnippet for lsp-mode. And why not. It's a good thing

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :demand t
    :config
    (yas-global-mode 1)
    (setq yas-snippet-dirs (list "~/.emacs.d/snippets")))
#+END_SRC
** Clojure

*** CIDER

Get the dependencies for cider

#+BEGIN_SRC emacs-lisp
  (use-package parseedn)
  (use-package pkg-info)
  (use-package queue)
  (use-package spinner)
  (use-package seq)
  (use-package sesman)
  (use-package flycheck-joker)
  (use-package buttercup)
#+END_SRC


Clojure mode and CIDER are dev versions locally

#+BEGIN_SRC emacs-lisp

    (use-package clojure-mode
      :load-path "~/projects/dev/clojure-mode"
      :config
      (setq clojure-toplevel-inside-comment-form t)
      (setq clojure-indent-style 'align-arguments)
      (put-clojure-indent 'dofor 1)
      (put-clojure-indent 'match 1)

      (put-clojure-indent 'context 1)
      (put-clojure-indent 'GET 1)
      (put-clojure-indent 'compojure/GET 1)
      (put-clojure-indent 'compojure/POST 1)
      (put-clojure-indent 'compojure/PATCH 1)
      (put-clojure-indent 'compojure/PUT 1)
      (put-clojure-indent 'compojure/DELETE 1)
      (put-clojure-indent 'POST 1)
      (put-clojure-indent 'PATCH 1)
      (put-clojure-indent 'DELETE 1))

    (use-package cider
      :load-path "~/projects/dev/cider/"
      :init
      (load "cider-autoloads" t t)
      :config
      (setq cider-invert-insert-eval-p t)
      (setq cider-switch-to-repl-after-insert-p nil)
      (setq cider-switch-to-repl-on-insert-p nil)
      (setq cider-font-lock-dynamically t)
      (setq cider-show-error-buffer nil)
      (setq cider-repl-display-help-banner nil)
      (setq cider-repl-pop-to-buffer-on-connect 'display-only)
      (setq cider-repl-tab-command #'company-indent-or-complete-common)
      :bind (:map
             cider-repl-mode-map
             ("RET" . cider-repl-newline-and-indent)
             ("C-j" . cider-repl-return)
             :map
             paredit-mode-map
             ("C-j" . cider-repl-return))
  )
#+END_SRC

****  tooltip for doc stuff
#+BEGIN_SRC emacs-lisp
  (use-package pos-tip)

  (defun cider-tooltip-show ()
    (interactive)
    (if-let ((info (cider-var-info (thing-at-point 'symbol))))
        (nrepl-dbind-response info (doc arglists-str name ns)
          (pos-tip-show (format "%s : %s\n%s\n%s" ns (or name "") (or arglists-str "") (or doc ""))
                        nil
                        nil
                        nil
                        -1))
      (message "info not found")))

  (bind-key "C-c t" 'cider-tooltip-show)
#+END_SRC
*** LSP
indent-region-function


Use lsp-mode with the excellent lsp-clojure package.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :init
    (setq lsp-clojure-server-command '("bash" "-c" "cd ~/projects/clojure/clojure-lsp && lein run"))
    (setq lsp-enable-indentation nil)
    (setq lsp-enable-completion-at-point nil)
    ;; (setq indent-region-function #'clojure-indent-function)
    (add-hook 'clojure-mode-hook #'lsp)
    (add-hook 'clojurec-mode-hook #'lsp)
    (add-hook 'clojurescript-mode-hook #'lsp)
    :config
    (require 'lsp-clojure)
    (add-to-list 'lsp-language-id-configuration '(clojure-mode . "clojure"))
    (add-to-list 'lsp-language-id-configuration '(clojurec-mode . "clojure"))
    (add-to-list 'lsp-language-id-configuration '(clojurescript-mode . "clojurescript")))
#+END_SRC

Use the hydra I cooked up recently

#+BEGIN_SRC emacs-lisp
  (use-package lsp-clojure-hydra
    :after (lsp-mode lsp-mode cider)
    :load-path "~/projects/elisp/lsp-clojure-hydra"
    :bind (("C-c C-l" . lsp-clojure-refactor-menu/body)
           :map
           cider-mode-map
           ("C-c C-l" . lsp-clojure-refactor-menu/body)))
#+END_SRC
** Rust

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode)
  (use-package racer
    :config
    (add-hook 'rust-mode-hook #'racer-mode)
    (add-hook 'racer-mode-hook #'eldoc-mode)
    (add-hook 'racer-mode-hook #'company-mode)
    (setq company-tooltip-align-annotations t)
    :bind (:map
           rust-mode-map
           ("TAB" . company-indent-or-complete-common)))
#+END_SRC
** Elm

Packages for elm-mode

#+BEGIN_SRC emacs-lisp
  (use-package elm-mode)
  (use-package flycheck-elm)
#+END_SRC
** Haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode)
#+END_SRC
install intero
#+BEGIN_SRC emacs-lisp
  (use-package dante
    :ensure t
    :after haskell-mode
    :init
    (add-hook 'haskell-mode-hook 'flycheck-mode)
    (add-hook 'haskell-mode-hook 'dante-mode))

#+END_SRC
* Machine Configs
** Work

Var to check that we are on the work machine
#+BEGIN_SRC emacs-lisp
  (defconst personal/work-machine (string= system-name "dan-aclaimant-mbp.local"))
#+END_SRC
*** Connect to running services

#+BEGIN_SRC emacs-lisp
  (when personal/work-machine
    (defmacro aclaimant-cider-connection (name&dir port)
      `(defun ,(intern (format "aclaimant-jack-in-%s" (symbol-name name&dir))) ()
         ,(format "Jack into project %s and open its base directory." name&dir)
         (interactive)
         (let ((dir ,(format "~/projects/aclaimant/acl/src/aclaimant/"
                             (symbol-name name&dir))))
           (cider-connect (list :host "local.aclaimant.com" :port ,port
                                :project-dir dir)))))

    (defun personal/aclaimant-connect (name&dir host port options)
      (let ((dir (format "~/projects/aclaimant/acl/src/aclaimant/" (symbol-name name&dir))))
        (cider-connect (append (list :host host :port port
                                     :project-dir dir)
                               options))))

    (aclaimant-cider-connection service 7000)
    (aclaimant-cider-connection jobs 7001)
    (aclaimant-cider-connection alerter 7002)
    (aclaimant-cider-connection twilio 7004)

    (defun aclaimant-jack-in-dashboard ()
      (interactive)
      (cider-connect-cljs (list :host "localhost"
                                :port 7888
                                :cljs-repl-type 'figwheel-connected
                                'project-dir "~/projects/aclaimant/acl")))

    (resize-window-add-choice ?u (lambda () (dired "~/projects/aclaimant/acl"))
                              "Work projects"))

#+END_SRC
*** Font size

#+BEGIN_SRC emacs-lisp
  (when personal/work-machine
    (defun personal/set-font ()
      (interactive)
      (set-face-attribute 'default nil :height 140))

    (personal/set-font))
#+END_SRC

*** TODO Ligatures

Switch away from ligatures hoping to diagnose some memory woes on osx. Need that sweet sweet shell though

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :demand t
    :init
    (exec-path-from-shell-initialize))
#+END_SRC

*** Random assorteds

#+BEGIN_SRC emacs-lisp
  (when personal/work-machine
    (setq mac-command-modifier 'meta)
    (global-display-line-numbers-mode +1))
#+END_SRC
** Linux machine

are we on that machine?

#+BEGIN_SRC emacs-lisp
  (defconst personal/linux-machine (string= system-name "pop-os"))
#+END_SRC


*** Font size

thinkpad machine has a 2500 screen and needs "manual" scaling. Work machine scales better. Year of the linux desktop

#+BEGIN_SRC emacs-lisp
  (when personal/linux-machine
    (defun personal/set-font ()
      (interactive)
      (set-face-attribute 'default nil :height 130)))
#+END_SRC
** Any

*** Set font

For some reason this was getting lost in the startup shenanigans so we set it once things settle down.

#+BEGIN_SRC emacs-lisp
  (set-frame-font "Fira Code")
  (run-with-idle-timer 0 nil #'personal/set-font)
#+END_SRC

*** TODO

* Post

** Restore gc

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold personal/original-gc-threshold)
#+END_SRC
